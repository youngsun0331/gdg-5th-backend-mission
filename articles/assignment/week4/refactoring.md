# 예외처리, AOP, 리팩토링 원칙


# 1.예외처리

## 예외의 종류

+ 에러(Error)
+ 예외(Exception)
    + 체크 예외
    + 언체크 예외

## 에러
Error는 메모리가 부족하는 등과 같이 시스템이 비정상적인 상황인 경우에 사용한다  
주로 JVM에서 발생시키기 때문에 에플리케이션 코드에서 잡으면 안된다  
잡아도 대응할 방법이 없다.

## 예외
애플리케이션 코드에서 예외가 발생했을때 사용한다.
체크 예외와 언체크 예외로 구분된다

### 체크예외
RuntimeException 클래스를 상속받지 않은 예외 클래스들이다.  
체크 예외는 **복구 가능성이 있는 예외** 처리로  
예외를 처리하는 코드를 함께 작성한다.  
만약 예외를 처리하지 않는다면 **컴파일 에러**가 발생한다
하지만 개발자가 모든 체크 예외를 처리해줘야 하고  
실제로 애플리케이션에서 발생하는 예외들은 복구 불가능 경우가 많다.  
그래서 실제 개발에서는 대부분 언체크 예외를 사용한다

### 언체크 예외 
RuntimeTimeException 클래스를 상속받는 예외 클래스들은 복구 가능성이 없는 예외들이다  
그러므로 컴파일러가 예외처리를 강제하지 않는다.  
그래서 언체크 예외라 불리며 예상했던 상황에서 발생하는 예외들이다.  
대표적으로 NullPointerException이나 IllegalArgumentException 등과 같은 것들이 있다.  

>! 스프링 프레임워크가 제공하는 트랜잭션안에 에러 발생시  
>체크 예외는 롤백이 되지 않고 
>언체크 예외는 롤백이 된다  

## 예외처리 실무적 의미
+ 체크예외 - 비즈니스
+ 언체크 예외 - 시스템

### 체크 예외 - 비즈니스
1. 컴파일러가 처리를 강제한다.  
이것은 예상 가능하고 복구 가능한 상황이다("잔액부족","잘못된 입력")  

2. 트랜잭션 유지  
체크 예외는 롤백을 유발하지 않는다.  
비즈니스 오류가 발생하더라도(예시 :"잔액 부족")    
트랜직션을 유발하거나, 개발자가 명시적으로 롤백 여부를 결정할 수 있게 된다.


### 언체크 예외 - 시스템

## 전역 예외 처리 방식

`@ContorllerAdivce`  
예외를 전역적으로 처리하기 위한 어노테이션.  
여러 개의 컨트롤러에서 발생한 동일한 예외에 대해 한 곳에서 처리할 수 있게 해줌.  

@RestControllerAdvice 어노테이션은 뷰를 렌더링 하는 대신 message conversion을 통해 json을 반환  
-> @ControllerAdvice + @ResponseBody


`@ExceptionHandler`  
+ 특정 예외가 발생했을 때, 그 예외를 처리할 메서드를 지정하는 어노테이션.  
value로 원하는 예외를 설정해 던져줄 수 있음  

## 에러 응답 포맷 설계

### ResponseEntity
httpheaders, httpbody , httpstatus 데이터를 갖는다  

### 공통 응답 클래스 ApiResponse
사용 이유
1. 일관된 응답 형식 유지
2. 로깅 및 모니터링
3. 보안 및 데이터 검증



# AOP

## AOP
Aspect Oriented Programming의 약자로 관점 지향 프로그래밍 이라고 불린다.  
관점 지향은 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고  
그 관점을 기준으로 각각 모듈화 하겠다는 것 이다.  

## AOP의 주요 개념

1. Aspect : 흩어진 관심사를 모듈화 한 것. 주로 부가기능을 모듈화 함
2. Target : Aspect를 적용하는 곳(클래스, 메서드..)
3. Advice : 실질적으로 어떤 일을 해야할 지에 대한것, 실질적인 부가기능을 담은 구현체
4. JointPoint : Advice가 적용될 위치, 끼어들 수 있는 지점. 메서드 진입 지점, 생성자 호출 시점, 필드에서 값을 꺼내올 때 등 다양한 시점에 적용 가능
5. PointCut : JointPoint의 상세한 스펙을 정의한 것.  
'A란 메서드의 진입 시점에 호출할 것'과 같이 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있음.

## 스프링 AOP 특징
+ 프록시 패턴 기반의 AOP 구현체, 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기 위해서임
+ 스프링 빈에만 AOP를 적용 가능
+ 모든 AOP 기능을 제공하는 것이 아닌 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서  
가장 흔한 문제

>! 프록시 패턴  
>객체가 메모리에 올라와 있지 않아도 
>기본적인 정보 참조 가능

## 왜 Spring은 프록시 방식을 쓸까?
만약에 프록시 객체 없이 Target 객체를 사용한다 가정하자  
Aspect 클래스에 정의된 부가 기능을 사용 하기 위해 우리는 직접 호출 해야된다  
이경우 AOP를 적용하지 않았을 때와 동일한 문제 발생  

>정리  
>송금 = A, 로깅 프로그램 = B  
>프록시 없이 A를 가동한다면?  
>A 실행후 B 호출  
>필요할 때 마다 B 호출해야됨 -> 순수 비즈니스 로직에 집중 x, 반복 호출문제  
>A 클래스 혹은 상위 인터페이스를 상속하는 프록시 클래스 생성


## 트랜잭션
역시 프록시 형태로 동작한다


1. private는 트랜잭션 처리를 할 수 없다  
자식이 private이면 프록시 객체에서 호출 할 수 없음

2. 트랜잭션은 객체 외부에서 처음 진입하는 메서드를 기준으로 동작한다  

다음과 같이 A, B, C의 메서드가 있다고 가정하자.  

A 메서드는 쿠폰을 생성하는 메서드이고, 트랜잭션이 적용되어 있다.  
B 메서드는 A 메서드를 3번 호출하고, 트랜잭션이 적용되어 있지 않다.  
C 메서드도 A 메서드를 3번 호출한다. 하지만 C에는 트랜잭션이 적용되어 있다.  

B, C 메서드 모두 정상적인 경우라면 쿠폰 3개를 신규 생성한다.    
그렇다면 B와 C 메서드는 동일한 기능을 한다고 볼 수 있을까?  

쿠폰을 3개를 모두 생성한 뒤 오류가 발생했다고 가정해보자.  

결론은 다음과 같다
**B** 메서드 사용시 DB에 3개의 쿠폰이 발급 돼 있다  
**C** 메서드 사용시 DB엔 쿠폰이 하나도 없다  


# 리팩토링 원칙

## 리팩토링 정의
리팩토링이란, SW의 동작은 유지하면서 가독성을 높인다

목표
1. 코드의 복잡성 감소
2. 유지보수 개선
3. 확장성 높임
4. 가독성 향상


금지 
1. 기능 변경/추가
2. 버그 수정
3. 성능 개선
4. 버전 업데이트

## Clean Code

- 리팩토링 원칙

Clean Code, SOLID, 중복 제거(DRY), 단순함(KISS), YAGNI 개념
“나쁜 코드 vs 개선 코드” 예시에 대해서 알아보기


