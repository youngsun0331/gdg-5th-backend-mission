# 정리
1. 컨트롤러
2. 서비스
3. 레포
4. 엔티티
5. DTO


# ORM 이해하기

# 영속성 이해하기
## 영속성(Persistence Context)
Persistence Context  
직관적으로 이해 해 보자  
영원히 존재하는 성질?

## EntityManagerFactory
Entity Manager 를 만들고 구성하는 법을 제공하는 interface 


## EntityManager
DB table 과 mapping 된 객체인 Entity에 대한 CRUD 작업을 수행하기 위한  
method들을 제공, Entity의 라이프 사이클과 영속성 관리등을 담당함

## Persistence Context
1. entity의 영속화에 관여하며
2. entity들이 DB로 바로 가지 않고 entity를 저장하는 환경으로서의 역활을 함  

> ! Context
> 사전적 의미 자체는 맥락이나 문맥을 의미하지만  
> 개발에서 말하는 Context의 주된 뜻은 이벤트가 일어나는 조건, 환경 등이 된다.
> 코드의 배경이 되는 조건, 환경정도


## flush
flush는 영속성 컨텍스트의 변경된 내용을 DB에 반영하기 위해 사용한다.


1. JPA의 변경 감지를 통해 영속성 컨텍스트에 있는 모든 Entity를 스냅샷과 비교하여 변경된 Entity를 찾고 수정된 엔티티는 수정 쿼리를 만들어서 쓰기 지연소에 저장한다

2. 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송한다

### flush 하는 방법

1. 트랜잭션 커밋 시 플러시 자동 호출
2. JPQL 쿼리 실행시 플러시 자동 호출

 
flush 정리  
DB에 데이터를 보내지 않고 캐쉬에 기억했다가  
캐쉬에 있는 데이터를 DB에 반영하는것

## 비영속, 준영속
비영속 = 영속성 컨텍스트와 전혀 관련 없는 상태  
준영속 = 영속성 컨텍스트의 관리를 더이상 받지 않는 상태

## dirty checking
dirty는 엔티티 데이터의 변경된 부분을 뜻함  
JPA는 변경된 부분을 알아서 확인해주는 작업(dirty checking)을 해줌  
그러므로 update에 관련된 쿼리를 작성할 필요가 없음
비영속 ,준영속 상태의 엔티티는 Dirty Checking 대상에 포함되 않는다  
영속된 상태의 엔티티만 값을 변경해도 데이터베이스에 반영됨

### 더티 체킹 조건
1. 영속성 컨텍스트에서 관리되는 엔티티
2. 트랜잭션이 커밋됐을 때


## Repository 계층 키워드 학습
`@ComponentScan`어노테이션을 통해서  
`@Component` 어노테이션이 붙은 클래스들을 빈으로 등록해준다


`@Transactional`  
DB 한정이 아닌 **기능 동작**에 관한 원자성을 보장하는 interface이다.  
하지만 Spring이 데이터 저장소는 아니기 때문에 DB등 다른 솔루션 없이 원자성을 보장하는 것에 한계가 있다.  
그러다 보니 DB 원자성 보장에 많이 활용되는 편  

`@Transactional`이 클래스 내부 메서드에 붙을때 Spring은 해당 메서드에 대한 프록시를 만든다.  
프록시 패턴은 디자인 패턴 중 하나로, 어떤 코드를 감싸면서 추가적인 연산을 수행하도록 강제하는 방법이다

> 프록시 패턴이란 ?
> 프록시를 번역하면 대리자, 대변인의 의미를 갖고있다  
> 프로그램에서도 프록시에게 어떤 일을 대신 시키는 것 이다


+ 서비스 클래스에서 트랜잭션을 사용할경우  

    + 해당 코드 내의 메소드를 호출할 때 영속성 컨텍스트가 생긴다.
    + 영속성 컨텍스트는 트랜잭션 AOP가 트랜잭션을 시작할 때 생겨나고 메서드가 종료되어 트랜잭션AOP가 트랜잭션을 커밋할 경우 flush되면서 해당 내용 반영 이후 영속성 종료



`@Repository`  
DB 접근이 가능한 객체를 나타냄  
스프링 빈으로 등록하여 사용될 수 있게 하는 역할을 맡음  
트랜잭션 어노테이션을 통해서 스프링 트랜잭션을 관리할 수 있게 됨

`@Entity`  
JPA에서 사용할 엔티티 이름 지정  
name을 쓰지 않을 경우 클래스이름을 엔티티 이름으로 지정
> order는 이미 지정돼 있는 이름이라 오류뜸  
> orders로 사용할것


# 구현시 문제점

## 명세서 관련

### 1.Entity 명세서(변수 이름 지정)
Entity를 만들때 어떤 명세서를 봐야되는가
ERD 다이어그램 먼저 만들어야 될거같다
미리 명세

### 2. DB 에서 list를 추출할때

재고 구매의 문제점

POST /order

```json
//Input
{
    "items" : [ 
    {
        "name" : "apple", 
        "cnt" : 20 //물건 구매 갯수
    },
    {
        "name" : "water",
        "cnt" : 20
    }
    ]

}
```

```Json
// OUTPUT
{
    "totalPrice": 40000 ,
    "cart" : [
        {
            "name" : "apple",
            "cnt" : 20,
            "price" : 20000
        },
        {
            "name" : "water",
            "cnt" : 20,
            "price" : 20000

        }]
}
    
```



output에서 리스트로 빠져 나오는데 어떻게 쿼리를 작성해야될까

### 자바 예외처리 할때
Response객체로 예외처리하면 swagger 에서도 보이지만
Exception 던지면 안보인다 어떻게 예외처리를 해야될까?

### DTO 객체를 받을때
Entity 로 받고 응답 DTO로 값 옮기기
처음부터 응답 DTO로 받기

-> N+1 문제와 연관 있다고 하 
>N+1문제란?

